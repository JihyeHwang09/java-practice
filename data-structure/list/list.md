# List 컬렉션
 - List 컬렉션은 인덱스 순서로 저장이 되며, 중복된 데이터가 저장이 가능하다. 
 - 구조적으로 데이터를 일렬로 늘여놓는 구조를 갖는다. 
 - 객체(데이터 등)를 저장하면 인덱스가 자동으로 부여되고 부여된 인덱스를 통해 데이터의 검색 및 삭제가 가능하다.
 - (인덱스에는 데이터가 저장되어 있는 참조 값을 갖는다.)  
 - List 컬렉션을 구현하는 대표적인 클래스들은 ArrayList, Vector, LinkedList가 있다.
 - List 인터페이스를 구현하는 클래스들이기 때문에 공통적으로 사용할 수 있는 메서드들이 많다. 
 - 기본적인 List의 메소드
 
 |리턴 타입|메소드| 내 용|
 |---|---|---|
 |boolean| add(E e) |데이터 추가 |
 |void|add(int index, E element)|해당 인덱스에 데이터 **추가**|
 |E|set(int index, E element)|해당 인덱스에 데이터 **대체**|
 |E|get(int index)|해당 인덱스에 데이터 **리턴**|
 |boolean|isEmpty()|데이터의 유무 리턴|
 |int|size()|저장된 데이터의 수 리턴|
 |void|clear()|저장된 데이터 모두 삭제|
 |E|remove(int index)|해당 인덱스의 데이터 삭제|
 |boolean|remove(Object o)|해당 데이터 삭제|
 |Iterator<E>|iterator()|반복자(Iterator) 생성|
---
 
## ArrayList
- ArrayList는 List 인터페이스를 구현한 클래스이다.
- 설정된 저장 용량(capacity)보다 많은 데이터가 들어오면 자동으로 용량이 늘어난다.

- ArrayList를 생성하는 방법
```java
List<E> 객체명 = new ArrayList<E> ([초기 저장용량]);
```
- 초기 저장용량을 생략할 경우, 기본적으로 10의 저장용량을 갖는다.
- E는 제네릭 타입을 의미하는데 생략할 경우, Object 타입이 된다.
- Object는 모든 데이터 타입이 저장 가능하지만, **데이터를 추가하거나 검색할 때 형 변환**을 해야 한다.
자료구조에는 주로 동일한 데이터 타입을 저장하기 때문에 -> **제네릭 타입을 지정하고 사용하는 것이 좋다.**
- 기본적으로 데이터를 추가할 때는 **인덱스 순으로 자동 저장**된다.
 이때 중간에 데이터를 추가하거나 삭제할 경우에는 인덱스가 한 칸씩 뒤로 밀리거나 당겨진다.

 ---
## Vector
- ArrayList와 동일한 구조를 갖는다.
- 차이점: Vector는 자동 동기화를 보장하므로 멀티 스레드 환경에서 안정적으로 사용이 가능하다.
    - But, 단일 스레드에서는 ArrayList가 성능이 더 좋다.
-Vector를 생성하는 방법
```java
List<E> list = new Vector<e>([초기용량,</e> 증가용량]);
```
- 초기용량과 증가용량을 생략하면 기본 값인 `0`으로 설정된다.

---
## LinkedList
- List의 구현 클래스이므로 ArrayList나 Vector와 사용 방법은 동일하다. 
- But, **구조는 다르게 구성되어 있다.** 
- 위의 컬렉션들은 인덱스로 데이터를 관리하지만, `LinkedList`는 **인접한 곳을 링크하여 체인처럼 관리**한다.
- LinkedList는 중간의 데이터를 **삭제**할 때, 인접한 곳의 링크만을 변경하면 되기 때문에 
- 중간에 데이터를 추가/삭제하는 경우 **처리 속도가 빠르다.** 
|구분|순차적 추가/삭제|중간 추가/삭제||
|---|---|---|---|
|ArrayList|빠름|느림|빠름|
|LinkedList|느림|빠름|느림|
```java
List<E> list = new LinkedList<E>();
```
